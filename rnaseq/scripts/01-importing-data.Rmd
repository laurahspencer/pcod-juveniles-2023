---
title: "01-importing-data"
author: "Laura Spencer"
date: '2024-04-05'
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
      number_sections: true
---

In this notebook I will import gene counts file that were generated by STAR 

### Check working directory 

```{r}
getwd()
```

### Load libraries and source scripts 

```{r, echo=FALSE, message=FALSE, warning=FALSE, results='hide'}

# source("../references/biostats.R")

# Add all required libraries that are installed with install.packages() here
list.of.packages <- c("RCurl", "tidyverse", "vegan", "pheatmap", "pastecs", "factoextra", "FactoMineR", "RColorBrewer", "tibble", "reshape2", "plotly", "corrplot", "PerformanceAnalytics", "cowplot", "here", "janitor", "clipr", "googlesheets4", "ape")
# Add all libraries that are installed using BiocManager here
bioconductor.packages <- c("DESeq2", "WGCNA")

# Install BiocManager if needed
if(!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")

# Get names of all required packages that aren't installed
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[, "Package"])]
new.bioc.packages <- bioconductor.packages[!(bioconductor.packages %in% installed.packages()[, "Package"])]
# Install all new packages
if(length(new.packages)) install.packages(new.packages)
if(length(new.bioc.packages)) BiocManager::install(new.bioc.packages)

# Load all required libraries
all.packages <- c(list.of.packages, bioconductor.packages)
lapply(all.packages, FUN = function(X) {
  do.call("require", list(X))
})

```

Before I can successfully run featureCounts using the correct gene identifier -- the NCBI gene id which is denoted by "db_xref" in the 9th column -- I need to remove the few genes from the GTF that do NOT have a db_xref in some exons. This is better than using the "gene_id" identifier, since there are many duplicated gene_id's. Here is my code to explore the GTF and determine which genes to remove and test to make sure I can successfully use grep to identify the rows to remove. The actual removal is executed in the featurecounts2.sh script. 

```{r}
pcod.gtf <- read.gff(file = "../../references/GCF_031168955.1_ASM3116895v1_genomic.gtf", GFF3 = F) %>%
  mutate(gene_id=gsub("gene_id |;|\"", "", str_extract(attributes, "gene_id (.*?);")),
       ncbi_id=gsub("db_xref |;|\"|GeneID:", "", str_extract(attributes, "db_xref (.*?);")),
       biotype=gsub("transcript_biotype |;|\"", "", str_extract(attributes, "transcript_biotype (.*?);")),
       exon=gsub("exon_number |;|\"", "", str_extract(attributes, "exon_number (.*?);")))
```
# Prep GTF file for featureCounts 
# Some exons are missing NCBI gene IDs! Lots of exon ranges are duplicated! This is because there are multiple transcripts for each exon. Need to edit GTF to:
  1. Fill in missing ncbi gene ids 
  2. Include only necessary entries in attributes column, removing entries that vary by transcript (transcript_id, product, experiment, model_evidence information from attributes column)
  3. Add a unique identifier for each exon, specifically "ncbi_id:exon_number" 
  4. Filter for unique entries 
  
```{r}
# Create filtered gtf dataframe and write in GTF format
pcod.gtf.edited <- pcod.gtf %>%  
  group_by(gene_id) %>% fill(ncbi_id, .direction = "down") %>% #first fill in missing ncbi_id for the 113 exon/transcript entries
  select(seqname, source, feature, start, end, score, strand, frame, gene_id, ncbi_id, exon) %>%  distinct() %>% #filter for distinct features+ranges  
  mutate(feature_range=end-start) %>% group_by(feature, ncbi_id, exon) %>% dplyr::slice(which.max(feature_range)) %>%  #some exons have slightly different start/stop loci; only keep the one with largest range 
  mutate(attributes=paste("gene_id \"", gene_id, "\";", # add new attributes column with only necessary info 
                          " db_xref \"GeneID:", ncbi_id, "\";",
                          " exon_number \"", exon, "\";",
                          " ncbi_id_exon \"", ncbi_id, ":", exon, "\";", sep="")) %>%
  ungroup() %>% #remove grouping
  select(seqname, source, feature, start, end, score, strand, frame, attributes) #reorder columns to match GTF format 

# Write edited GTF to file with header lines
fn <- "../../references/GCF_031168955.1_ASM3116895v1_genomic_edited.gtf"
writeLines(read_lines(file = "../../references/GCF_031168955.1_ASM3116895v1_genomic.gtf")[1:5], fn)
write.table(pcod.gtf.edited, fn, append=TRUE, quote=FALSE, col.names = F, row.names = F, sep="\t")
```


```{r}
# check that genes and exons aren't repeated
read.gff(file = "../../references/GCF_031168955.1_ASM3116895v1_genomic_edited.gtf", GFF3 = F) %>%
  filter(feature=="exon") %>%
  mutate(ncbi_id_exon=gsub("ncbi_id_exon |;|\"", "", str_extract(attributes, "ncbi_id_exon (.*?);"))) %>% 
  group_by(ncbi_id_exon) %>% filter(n()>1)

read.gff(file = "../../references/GCF_031168955.1_ASM3116895v1_genomic_edited.gtf", GFF3 = F) %>%
  filter(feature=="gene") %>%
  mutate(gene_id=gsub("gene_id |;|\"", "", str_extract(attributes, "gene_id (.*?);")),
         ncbi_id=gsub("db_xref |;|\"", "", str_extract(attributes, "db_xref (.*?);"))) %>% 
  group_by(ncbi_id) %>% filter(n()>1)

#Looks good! Phew! 
```
```{bash}
cat "../../re
```


Other code I used to explore GTF file 

# ```{r}
# pcod.gtf %>% filter(feature=="exon") %>% filter(biotype=="transcript") %>% filter(!is.na(ncbi_id)) %>% select(-attributes) %>% group_by(ncbi_id, start, end, exon, strand) %>% filter(n()>1) #here are exon entries that are duplicated
# 
# # here's one exon that's repeated - why? The "product" is slightly different (transcript variant X1 vs. transcript variant X2)
# pcod.gtf %>% filter(feature=="exon") %>% filter(ncbi_id==132464981) %>% filter(start==1284513) %>% filter(end==1285850)

# # test filling in missing NCBI gene ids 
# exon_no_ncbi <- (pcod.gtf %>% filter(feature=="exon") %>% filter(is.na(ncbi_id)))$gene_id
# pcod.gtf.filled <- pcod.gtf %>% #filter(gene_id %in% exon_no_ncbi) %>%
#   group_by(gene_id) %>% fill(ncbi_id, .direction = "down") 
# 
# # Make sure only empty NCBI gene ids were filled 
# install.packages("diffdf")
# require("diffdf")
# diff.chk <- diffdf(pcod.gtf, pcod.gtf.filled)
# all(rownames(pcod.gtf %>% filter(is.na(ncbi_id))) == diff.chk$VarDiff_ncbi_id$..ROWNUMBER..) #looks good! 
# pcod.gtf[diff.chk$VarDiff_ncbi_id$..ROWNUMBER..,] %>% select(feature,gene_id,ncbi_id)
# 
# # Figure out which genes are duplicated 
# temp_dup <- (pcod.gtf %>% filter(feature=="gene") %>% group_by(gene_id) %>% filter(n()>1) %>% mutate(gene_id=gsub("\"", "", gene_id)))$gene_id
# 
# counts %>% as.data.frame() %>% rownames_to_column("gene_id") %>% filter(gene_id %in% temp) %>% select(-gene_id) %>% rowSums()
# intersect(temp, degs) 
# intersect(temp_dup, degs)
# 
# test.gtf <- read.gff(file = "../test.gtf", GFF3 = F) %>%
#   mutate(id=gsub("gene_id |;|gene-", "", str_extract(attributes, "gene_id (.*?);")),
#        ncbi_id=gsub("db_xref |;", "", str_extract(attributes, "db_xref (.*?);")),
#        name=gsub("Name=|;", "", str_extract(attributes, "Name=(.*?);")),
#        # parent=gsub("Parent=|;", "", str_extract(attributes, "Parent=(.*?);")),
#        # description=gsub("description=|;", "", str_extract(attributes, "description=(.*?);")),
#        gene=gsub("gene |;", "", str_extract(attributes, "gene (.*?);")),
#        biotype=gsub("transcript_biotype |;", "", str_extract(attributes, "transcript_biotype (.*?);")))
# 
# temp2 <- (test.gtf %>% filter(feature=="exon") %>% mutate(id=gsub("\"", "", id)))$id
# all(temp==temp2)
# 
# pcod.gtf %>% mutate(id=gsub("\"", "", id)) %>% filter(id %in% temp) %>% nrow() #number rows in original .gtf with genes we want to remove 
# 1314696-1314546 # number rows in original gtf - number rows in filtered gtf; should match 
# ```
# 
# This code filters to RETAIN rows with the below genes. To remove them I will add the tag -v (inverse) 
# 
# ```{bash}
# grep -E "C5T52_mgt22|C5T52_mgt01|C5T52_mgr02|C5T52_mgt02|C5T52_mgr01|C5T52_mgt03|C5T52_mgp13|C5T52_mgt04|C5T52_mgt05|C5T52_mgt06|C5T52_mgp12|C5T52_mgt07|C5T52_mgt08|C5T52_mgt09|C5T52_mgt10|C5T52_mgt11|C5T52_mgp11|C5T52_mgt12|C5T52_mgt13|C5T52_mgp10|C5T52_mgt14|C5T52_mgp09|C5T52_mgp08|C5T52_mgp07|C5T52_mgt15|C5T52_mgp06|C5T52_mgt16|C5T52_mgp05|C5T52_mgp04|C5T52_mgt17|C5T52_mgt18|C5T52_mgt19|C5T52_mgp03|C5T52_mgp02|C5T52_mgt20|C5T52_mgp01|C5T52_mgt21" "../../references/GCF_031168955.1_ASM3116895v1_genomic.gtf" > "../test.gtf" 
# ```


### Import sample info, library/file names, and then join 

NOTE: data is read directly from the GoogleSheet using a share link that was set to "anyone with a link can view"
 

```{r}
# library.stats <- read.csv("../data/library-prep-stats.csv", header=T) %>% clean_names %>%
#   dplyr::mutate_at(vars(tank_number, p_h, batch, date_extracted), as.factor)

# Read in sample key
sample.info <- read_delim("../../data/DESeq2_Sample_Information.txt", delim="\t") %>% 
  clean_names() %>% 
  mutate_at(vars(tank, temp_treatment, tissue_type), as.factor) %>%
  dplyr::rename("temperature"="temp_treatment", "tank_number"="tank") %>%
  mutate(temperature_tank=factor(paste(temperature, tank_number, sep="_")))

save(sample.info, file="../sample.info")
```

### Import library stats from MultiQC and from library prep

```{r}
multiqc.stats <- read.delim(file="../aligned/multiqc_star.txt", sep = "\t")
multiqc.stats <- multiqc.stats %>% clean_names() %>%
  left_join(sample.info %>% mutate(sample=as.character(sample_number)))
```

### Investigate possible correlations among # reads and prep stuff 

```{r}
cor(multiqc.stats %>% mutate(tank_number=as.numeric(tank_number)) %>% dplyr::select_if(is.numeric), use="complete.obs") %>% corrplot::corrplot(tl.cex=.75)
```

### Import GENE count data

#### Import data generated directly using the  STAR aligner step 

#### Generate tab-separated file that lists file names

```{bash}
rm ../aligned/countsfilenames.txt #rm file if it already exists
for file in ../aligned/*.ReadsPerGene.out.tab
do
filename="$(echo $file)"
sample="$(basename -a $filename | cut -d "." -f 1)"
printf "%s\t%s\n" "$filename" "sample_$sample" >> ../aligned/countsfilenames.txt
done
```

#### Confirm filenamems look good

```{bash}
head ../aligned/countsfilenames.txt
wc -l ../aligned/countsfilenames.txt
```

```{r}
# Using STAR aligned and STAR quantified counts
filenames <- read_delim(file="../aligned/countsfilenames.txt", col_names = c("filename", "sample"), delim = "\t")
files <- file.path(filenames$filename) #extract vector of filenames
all(file.exists(files)) #easy code to check that all files exist!

file_list <- vector(mode = "list", length = nrow(filenames))
names(file_list) <- c(filenames$sample)

for (i in 1:nrow(filenames)) {
    file_list[[i]] <- data.frame(read.delim(file=files[i]))[-1:-4,1:2]
    names(file_list[[i]]) <- c("gene", filenames$sample[i])
    print(paste("Total COUNTS,", names(file_list[[i]][2]), ":", prettyNum(sum(file_list[[i]][2]), big.mark=","), sep=" "))
    print(paste("Total GENES,", names(file_list[[i]][2]), ":", prettyNum(nrow(file_list[[i]] %>% filter(.[[2]] != 0)), big.mark=","), sep=" "))
}

(counts.star <- file_list %>% purrr::reduce(full_join, by = "gene") %>% column_to_rownames(var="gene"))
```

### Import counts generated using featurecounts from star alignments

```{r}
counts.fc <- data.frame(read.table("../aligned/featurecounts_gene", header = T, stringsAsFactors = F, fill = FALSE)) %>%
  column_to_rownames(var="Geneid")
counts.fc <- counts.fc %>% rename_all(~as.character(str_sub(colnames(counts.fc)) %>%
                            gsub("X.home.lspencer.pcod.juv.temp.", "", .) %>%
                            gsub(".Aligned.sortedByCoord.out.bam", "", .)) %>%
                              gsub("aligned.", "sample_", .)) %>% select(-Chr, -Start, -End, -Strand, -Length)
save(counts.fc, file = "../aligned/counts.fc")
```

### Decide which source of counts you'd like to use! (NOTE- they both are derived from STAR aligner)

```{r}
counts <- counts.fc
#counts <- counts.star
```


### Summarize counts and visualize (remove last column - that's undetermined counts)

```{r}
print(paste("Number of samples:", ncol(counts %>% dplyr::select(contains("sample"))), sep=" "))
print(paste("Total number of genes in dataframe:", prettyNum(nrow(counts), big.mark = ","), sep=" "))
print(paste("Average number of genes per sample:", prettyNum(mean(colSums(counts %>% dplyr::select(contains("sample")) != 0)) %>% round(), big.mark = ","), sep=" "))
print(paste("Total counts, all samples:", prettyNum(sum(colSums(counts %>% dplyr::select(contains("sample")))), big.mark = ","), sep=" "))
#print(paste("Counts for", colnames(counts %>% select(contains("PCG"))), ":",  prettyNum(colSums(counts %>% select(contains("PCG"))), big.mark = ","), sep=" "))

#inspect total counts by sample 
# sample 149 very high 
# sample 129 kinda low
ggplotly(
   ggplot(data.frame(colSums(counts %>% dplyr::select(contains("sample")))) %>% 
            dplyr::rename(count.total = 1) %>% rownames_to_column(var="sample")) + 
     geom_bar(aes(x=sample, y=count.total), stat = "identity") + ggtitle("Total count by sample") + 
              theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())) 
```

## OPTIONAL: FILTER WHOLE SAMPLES. 

Remove whole samples from the data set and sample info here if needed

```{r}
outliers <- c("sample_31", "sample_41", "sample_149", "sample_129")
#remove.list <- c(counts %>% select(contains(c("-S", "-G"))) %>% colnames(), outliers) #remove list for STAR-generated counts
remove.list <- c(counts %>% select(contains(c(".S", ".G"))) %>% colnames(), outliers) #remove list for featureCounts-generated counts
counts <- counts[ , which(names(counts) %!in% remove.list)]

# need to remove "RESUB-" from some sample names 
sample.info <- sample.info %>% mutate(sample_name=gsub("RESUB-", "", sample_name)) %>% filter(sample_name %in% colnames(counts))

nrow(sample.info) == ncol(counts) #should = TRUE
all(sort(sample.info$sample_name) == sort(colnames(counts))) #should = TRUE

# resave sample info object
save(sample.info, file="../sample.info")
View(sample.info)
```
### Transpose dataframe so each row = a sample (aka "objects"), and each column = genes (aka "variables") 

```{r}
#str(counts) #columns #1-#5 contain extraneous gene info (chr, start, end, strand, length). 
counts.t <- as.data.frame(t(counts)) #remove extraneous columns, transform data to have each sample a row, each column a gene
```

## Optional 

### Pre-filtering - remove low-frequency genes 

```{r}
keep1 <- colMeans(counts.t, na.rm=TRUE) >= 10 #identify genes with mean count >= 10 across all samples (excluding NAs = 10)
keep2 <- rowSums( counts >= 30 ) >= 0.1*69 #identify genes with counts>=30 across at minimum 10% of the samples
keep <- unique(c(names(which(keep1 == T)), names(which(keep2 == T)))) # list of genes meeting one of the two above criteria
counts.ts <- counts.t[,keep]

print(paste("# genes before filtering:", ncol(counts.t)))
print(paste("# genes remaining after pre-filtering:", ncol(counts.ts)))
print(paste("# of genes dropped:", ncol(counts.t) - ncol(counts.ts), sep=" "))
print(paste("% of fragments remaining after pre-filtering: ", signif(100*sum(counts.ts)/sum(counts.t), digits = 5), "%", sep=""))
print(paste("Number of fragments dropped: ", signif(sum(counts.t)-sum(counts.ts), digits = 5)))
print(paste("% of fragments dropped: ", signif(100*(sum(counts.t)-sum(counts.ts))/sum(counts.t), digits = 5), "%", sep=""))
print(paste("Number of fragments remaining: ", signif(sum(counts.ts), digits = 5)))
```
### Save counts file, and transformed counts file 

```{r}
save(counts, file = "../aligned/counts")
save(counts.t, file = "../aligned/counts.t")
save(counts.ts, file = "../aligned/counts.ts")
```

### Inspect read distribution before & after filtering

```{r}
# Plot distribution of unfiltered read counts across all samples 
#ggplotly(
ggplot(data = data.frame(rowMeans(counts)),
       aes(x = rowMeans.counts.)) +
  geom_histogram(fill = "grey") +
  xlim(1, 500) +
  theme_classic() +
  labs(title = "Distribution of unfiltered reads") +
  labs(y = "Density", x = "Raw read counts",
  title = "Read count distribution: untransformed, unnormalized, unfiltered\n(execept to remove 0's)")#)
```
### ANNOTATION OPTION 1: IF (big if) the DAVID folks add the Pacific cod genome to their DAVID database, I can use the NCBI gene IDs (aka Entrez Gene IDs) for enrichment analysis, which would likely be more accurate since every gene has an associated NCBI Gene ID.  But, if that doesn't happen, I'll need to still use Uniprot IDs. 

```{r}
pcod.gff <- read.gff(file = "../../references/GCF_031168955.1_ASM3116895v1_genomic.gff", GFF3 = TRUE) %>%
  mutate(id=gsub("ID=|;|gene-", "", str_extract(attributes, "ID=(.*?);")),
       ncbi_id=gsub("Dbxref=GeneID:|;", "", str_extract(attributes, "Dbxref=GeneID:(.*?);")),
       name=gsub("Name=|;", "", str_extract(attributes, "Name=(.*?);")),
       parent=gsub("Parent=|;", "", str_extract(attributes, "Parent=(.*?);")),
       description=gsub("description=|;", "", str_extract(attributes, "description=(.*?);")),
       gene=gsub("gene=|;", "", str_extract(attributes, "gene=(.*?);")),
       biotype=gsub("biotype=|;", "", str_extract(attributes, "biotype=(.*?);")),
       alias=gsub("Alias=|;", "", str_extract(attributes, "Alias=(.*?);")),
       AED=gsub("AED=|;", "", str_extract(attributes, "AED=(.*?);")),
       eAED=gsub("eAED=|;", "", str_extract(attributes, "eAED=(.*?);")),
       note=gsub("Note=|;", "", str_extract(attributes, "Note=(.*?);")),
       ontology_term=gsub("Ontology_term=|;", "", str_extract(attributes, "Ontology_term=(.*?);")),
       spid=gsub("SPID=|;", "", str_extract(attributes, "SPID=(.*?);")))

#pcod.gff %>% filter(type=="gene") %>% View()
```

### ANNOTATION OPTION 2: Annotate genes with Uniprot IDs and Gene Ontology info 

### Create bed file for just genes, which I will use with getfasta to extract gene sequences, which I will use with blast to identify gene function

IMPORTANT NOTE: GFF format use a 1-based coordinate system, while BED format uses a 0-based coordinate system. I therefore need to convert my coordinates. 

```{r}
read_delim(file = "../../references/GCF_031168955.1_ASM3116895v1_genomic.gff", delim = "\t", col_names = F, skip = 9) %>% 
  mutate(X3=as.factor(X3)) %>% filter(X3=="gene") %>%
  select(X1, X4, X5, X9) %>%
  mutate(X4=X4-1) %>% #convert from 1-based to 0-based by subtracting 1 from the start position 
  mutate(X9=str_remove(X9, "ID=")) %>%
  select(X1,X4,X5,X9) %>%
  write.table(., "../../references/GCF_031168955.1_ASM3116895v1_genes.bed", sep = "\t",
              col.names = F, row.names = F, quote = F)
```
Use `bedtools getfasta` to get sequences of genes, then `blastx` to annotate them with Uniprot/Swissprot database. **NOTE: This was done on Sedna with the slurm script `blast_genes`** (saved to the /home/lspencer/references/pcod-ncbi/ directory). 

#### Import blast results (Uniprot/Swissprot annotated genes)

blastx output format 6 is tab file with the following columns: 
1. qaccver = Query accesion.version
2. saccver = Subject accession.version
3. pident = Percentage of identical matches
4. length = Alignment length
5. mismatch = Number of mismatches
6. gapopen = Number of gap openings
7. qstart = Start of alignment in query
8. qend = End of alignment in query
9. sstart =  Start of alignment in subject
10. send = End of alignment in subject
11. evalue =  Expect value
12. bitscore = Bit score

```{r}
# Blast results from the gadMor3.0 genome fasta + gff to pull gene sequences: "../references/gadMor3.0_genes_blastx.tab"

pcod.blast <- 
  read_delim(file = "../../references/GCF_031168955.1_ASM3116895v1_blastx.tab", delim = "\t", 
                           col_names = c("qaccver", "saccver", "pident", "length", "mismatch", "gapopen", "qstart", "qend", "sstart", "send", "evalue", "bitscore")) %>%
  separate(qaccver, sep = ":|-", into = c("SeqID","Start","End")) %>%
  mutate_at(vars(Start, End), as.numeric) %>%
  separate(saccver, sep="\\|", into=c("na", "SPID", "gene.Uni"), remove = F) %>%
  dplyr::select(-na) %>% separate(gene.Uni, sep="_", into=c("gene.Uni", "species"), remove=T) %>%
  group_by(SeqID, Start, End) %>% dplyr::slice(which.min(evalue))  %>% # where multiple blast hits for same gene, select one with minimum e-value
  left_join(., read_delim(file="../../references/GCF_031168955.1_ASM3116895v1_genes.bed", delim="\t", col_names = c("SeqID", "Start", "End", "gene_info_pcod"))) %>%
  dplyr::select(gene_info_pcod, everything()) %>%
    mutate(
       ncbi_id=gsub("Dbxref=GeneID:|;", "", str_extract(gene_info_pcod, "Dbxref=GeneID:(.*?);")),
       description=gsub("description=|;", "", str_extract(gene_info_pcod, "description=(.*?);")),
       gene_pcod=gsub("gene=|;", "", str_extract(gene_info_pcod, "gene=(.*?);")),
       biotype=gsub("gene_biotype=", "", str_extract(gene_info_pcod, "gene_biotype=(.*)"))) %>%
  mutate(biotype=gsub(";.*", "", biotype)) %>%
  clean_names()
  
# E-VALUE FILTERING
# Count annotated genes with e-value filters
pcod.blast %>% filter(evalue < 1.0e-10) %>% nrow() # 18,644 genes have e-value <1e-10
pcod.blast %>% filter(evalue < 1.0e-15) %>% nrow() # 16,274 genes have e-value <1e-15
pcod.blast %>% filter(evalue < 1.0e-20) %>% nrow() # 13,557 genes have e-value <1e-20

# Filter blast results to meet desired e-value threshold
pcod.blast <- pcod.blast %>% filter(evalue < 1.0e-10)
save(pcod.blast, file = "../../references/pcod.blast")
#load(file = "../../references/pcod.blast")
```

### Annotate with GO terms and other info

#### NOTE:  I needed GO IDs and gene functions, which weren't included in the blast file.  So I copied the column containing all Uniprot IDs from the P.plat.blast object, then pasted those into the tool Uniprot batch retrieval tool (https://www.uniprot.org/uploadlists/), and selected the columns: Entry, Entry name, Protein names, Gene names, Organism, Gene ontology (biological process), Gene ontology (cellular componenet), Gene ontology (molecular processes), Gene ontology (GO), Gene ontology Ids. I then downloaded all entries to a tab file, saved as: /references/gadMor_genes_GO.tsv. Now I'll read that into R and join with the P.plat.blast dataframe to link GO IDs with genes for exploration and enrichment analyses. 

```{r}
# Use this code to get list of Uniprot SPID (gene identifiers) to input into the Uniprot Batch Retrieval tool, to obtain GO terms for each gene
pcod.blast %>% ungroup() %>% dplyr::select(spid) %>% distinct() %>%
  na.omit() %>% unlist() %>% as.vector() %>% write_clip()

# Add GO terms to Uniprot annotation object
pcod.blast.GO <- left_join(pcod.blast, read_delim(file = "../../references/GCF_031168955.1_ASM3116895v1_blast-uniprot-GO.tsv", 
                                                      delim = "\t") %>% clean_names(),
                             by = c("spid"="entry")) %>% ungroup()


save(pcod.blast.GO, file = "../../references/pcod.blast.GO")
#load(file = "../../references/pcod.blast.GO")
```

### Annotate gene counts dataframe

<!-- # STAR-generated counts  -->
<!-- ```{r} -->
<!-- counts.annot.pcod <- right_join( -->
<!--   pcod.blast %>% ungroup(), -->
<!--   counts.ts %>% t() %>% as.data.frame() %>% rownames_to_column("gene_pcod"), "gene_pcod") %>% -->
<!--   left_join(pcod.blast.GO %>% dplyr::select(gene_pcod, protein_names, gene_names), "gene_pcod") #%>% -->
<!--   #dplyr::select(Chr, Start, End, Strand, Length, geneID, evalue, SPID, gene.Uni, species, pident, gene_names, protein_names, everything()) -->

<!-- save(counts.annot.pcod, file = "../aligned/counts.annot.pcod") -->
<!-- write.csv(counts.annot.pcod, file = "../aligned/counts_annotated_pcod.csv", row.names = F, quote = F) -->
<!-- ``` -->

# featureCounts-generated counts 
```{r}
counts.annot.pcod <- right_join(
  pcod.blast %>% ungroup(),
  counts.ts %>% t() %>% as.data.frame() %>% rownames_to_column("gene") %>% mutate(ncbi_id=gsub("GeneID:", "", gene))) %>%
  left_join(pcod.blast.GO %>% dplyr::select(ncbi_id, protein_names, gene_names), "ncbi_id") #%>%
  #dplyr::select(Chr, Start, End, Strand, Length, geneID, evalue, SPID, gene.Uni, species, pident, gene_names, protein_names, everything())

save(counts.annot.pcod, file = "../aligned/counts.annot.pcod")
write.csv(counts.annot.pcod, file = "../aligned/counts_annotated_pcod.csv", row.names = F, quote = F)
```

```{r}
View(counts.annot.pcod)
#LOC132464016
```

#### How many of our analyzed genes are annotated? Answer- 12,477

```{r}
right_join(
  pcod.blast %>% ungroup() %>% dplyr::select(gene_pcod, ncbi_id, spid, gene_uni, species, pident, evalue),
  counts.ts %>% t() %>% as.data.frame() %>% rownames_to_column(var = "ncbi_id") %>% 
    mutate(ncbi_id=gsub("GeneID:", "", ncbi_id)), "ncbi_id") %>% filter(!is.na(spid)) %>%
  nrow()
```

#### Here's the total number of genes in the Pacific cod gff: 30,325 genes

```{r}
read_delim(file = "../../references/GCF_031168955.1_ASM3116895v1_genomic.gff", delim = "\t", col_names = F, skip = 9) %>% 
  mutate(X3=as.factor(X3)) %>% filter(X3=="gene")
```

Import EXON counts!

```{r}
pcod.gtf %>% filter(feature=="exon") %>% select(ncbi_id, start, end) %>%
  group_by(ncbi_id, start, end) %>% distinct()
  left_join(pcod.gtf)
```


```{r}
exon.counts <- data.frame(read.table("../aligned/featurecounts_exon", header = T, stringsAsFactors = F, fill = FALSE)) %>%
  column_to_rownames(var="Geneid")
exon.counts <- exon.counts %>% rename_all(~as.character(str_sub(colnames(exon.counts)) %>%
                            gsub("X.home.lspencer.pcod.juv.temp.", "", .) %>%
                            gsub(".Aligned.sortedByCoord.out.bam", "", .)) %>%
                              gsub("aligned.", "sample_", .)) %>% select(-Chr, -Start, -End, -Strand, -Length)
save(exon.counts, file = "../aligned/exon.counts")
```

### Summarize counts and visualize (remove last column - that's undetermined counts)

```{r}
print(paste("Number of samples:", ncol(exon.counts %>% dplyr::select(contains("sample"))), sep=" "))
print(paste("Total number of exons in dataframe:", prettyNum(nrow(exon.counts), big.mark = ","), sep=" "))
print(paste("Average number of exons per sample:", prettyNum(mean(colSums(exon.counts %>% dplyr::select(contains("sample")) != 0)) %>% round(), big.mark = ","), sep=" "))
print(paste("Total exon.counts, all samples:", prettyNum(sum(colSums(exon.counts %>% dplyr::select(contains("sample")))), big.mark = ","), sep=" "))
#print(paste("exon.counts for", colnames(exon.counts %>% select(contains("PCG"))), ":",  prettyNum(colSums(exon.counts %>% select(contains("PCG"))), big.mark = ","), sep=" "))

#inspect total exon.counts by sample 
# sample 149 very high 
# sample 129 kinda low
ggplotly(
   ggplot(data.frame(colSums(exon.counts %>% dplyr::select(contains("sample")))) %>% 
            dplyr::rename(count.total = 1) %>% rownames_to_column(var="sample")) + 
     geom_bar(aes(x=sample, y=count.total), stat = "identity") + ggtitle("Total count by sample") + 
              theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())) 
```

## OPTIONAL: FILTER WHOLE SAMPLES. 

Remove whole samples from the data set and sample info here if needed

USE THIS CODE TO REMOVE SPLEEN AND GILL SAMPLES FOR THIS ANALYSIS, LEAVE ONLY LIVER SAMPLES 

```{r}
outliers <- c("sample_31", "sample_41", "sample_149", "sample_129")
#remove.list <- c(exon.counts %>% select(contains(c("-S", "-G"))) %>% colnames(), outliers) #remove list for STAR-generated exon.counts
remove.list <- c(exon.counts %>% select(contains(c(".S", ".G"))) %>% colnames(), outliers) #remove list for featureCounts-generated counts
exon.counts <- exon.counts[ , which(names(exon.counts) %!in% remove.list)]
nrow(sample.info) == ncol(exon.counts) #should = TRUE
all(sort(sample.info$sample_name) == sort(colnames(exon.counts))) #should = TRUE
```

USE THIS CODE TO REMOVE OUTLIER SAMPLES BY NAME 

```{r}
# remove.list <- c("PCG194", "PCG137")
# exon.counts <- exon.counts[ , -which(names(exon.counts) %in% remove.list)]
# sample.info <- sample.info[ -which(sample.info$sample_name %in% remove.list), ]
# 
# # resave sample info object
# save(sample.info, file="../data/sample.info")
# 
# nrow(sample.info) == ncol(exon.counts) #should = TRUE
```

## OPTIONAL: FILTER WHOLE SCAFFOLDS 

This code provides the option to remove data that mapped to scaffolds 105+. This is possibly beneficial because I don't know whether or not those scaffolds are also included within scaffolds 1-104 (i.e. the chromosomes). 

NOTE:  For exploration purposes I will NOT remove them, and will see if expressed data mapping to scaffolds 105+ have the exact same genes/counts as on chromosomes. 

After preliminary examination of blast results (by looking at genes, lengths, and counts) it's difficult to tell whether the scaffolds 105+ are subsets of the chromosomes 1-104. For now I will retain scaffolds 105+. 


```{r}
# exon.counts <- exon.counts %>% separate(Chr, into = c("X", "Y", "scaffold"), sep = "_", remove = F) %>%
#   mutate(scaffold=as.integer(scaffold)) %>% filter(scaffold<=104) %>% dplyr::select(-X, -Y, -scaffold)
```

### Optional: FILTER GENES THAT ARE OUTLIERS IN OUTLIER SAMPLES- NOT USED AS OF 12/2/2022

```{r}
# exon.counts <- exon.counts[-which(rownames(exon.counts) %in% outliers),]
```

### Transpose dataframe so each row = a sample (aka "objects"), and each column = genes (aka "variables") 
```{r}
#str(exon.counts) #columns #1-#5 contain extraneous gene info (chr, start, end, strand, length). 
exon.counts.t <- as.data.frame(t(exon.counts)) #remove extraneous columns, transform data to have each sample a row, each column a gene
```

## Optional 

### Pre-filtering - remove low-frequency genes 

NOTE: Should i do this? DESeq2 throws out low-frequency genes anyway, BUT other folks do pre-filter. For example in https://doi.org/10.1186/s12864-017-4392-0 "Genes with mean count less than ten across all samples were removed."

```{r}
keep1 <- colMeans(exon.counts.t, na.rm=TRUE) >= 10 #identify exon with mean count >= 10 across all samples (excluding NAs = 10)
keep2 <- rowSums( exon.counts >= 10 ) >= 0.1*69 #identify exons with exon.counts>=10 across at minimum 10% of the samples
keep <- unique(c(names(which(keep1 == T)), names(which(keep2 == T)))) # list of genes meeting one of the two above criteria
exon.counts.ts <- exon.counts.t[,keep]

print(paste("# exons before filtering:", ncol(exon.counts.t)))
print(paste("# exons remaining after pre-filtering:", ncol(exon.counts.ts)))
print(paste("# of exons dropped:", ncol(exon.counts.t) - ncol(exon.counts.ts), sep=" "))
print(paste("% of fragments remaining after pre-filtering: ", signif(100*sum(exon.counts.ts)/sum(exon.counts.t), digits = 5), "%", sep=""))
print(paste("Number of fragments dropped: ", signif(sum(exon.counts.t)-sum(exon.counts.ts), digits = 5)))
print(paste("% of fragments dropped: ", signif(100*(sum(exon.counts.t)-sum(exon.counts.ts))/sum(exon.counts.t), digits = 5), "%", sep=""))
print(paste("Number of fragments remaining: ", signif(sum(exon.counts.ts), digits = 5)))
```
### Save exon.counts file, and transformed exon.counts file 
```{r}
save(exon.counts, file = "../aligned/exon.counts")
save(exon.counts.t, file = "../aligned/exon.counts.t")
save(exon.counts.ts, file = "../aligned/exon.counts.ts")
```

### Inspect read distribution before & after filtering

```{r}
# Plot distribution of unfiltered read exon.counts across all samples 
#ggplotly(
ggplot(data = data.frame(rowMeans(exon.counts)),
       aes(x = rowMeans.exon.counts.)) +
  geom_histogram(fill = "grey") +
  xlim(1, 500) + 
  ylim(0,30000) +
  theme_classic() +
  labs(title = "Distribution of unfiltered reads") +
  labs(y = "Density", x = "Raw read exon.counts",
  title = "Read count distribution: untransformed, unnormalized, unfiltered\n(execept to remove 0's)")#)
```
